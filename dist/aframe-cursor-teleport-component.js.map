{"version":3,"file":"aframe-cursor-teleport-component.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;ACVA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD,iBAAiB,+BAA+B;AAChD,yBAAyB,6BAA6B;AACtD,wBAAwB,8BAA8B;AACtD,sBAAsB,6BAA6B;AACnD,uBAAuB,+BAA+B;AACtD,qBAAqB,yBAAyB,oBAAoB;AAClE,uBAAuB;AACvB,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yDAAyD;;AAEzD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://aframe-cursor-teleport-component/webpack/universalModuleDefinition","webpack://aframe-cursor-teleport-component/./index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","/* global AFRAME, THREE */\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error(\n    'Component attempted to register before AFRAME was available.'\n  );\n}\n\n/**\n * Cursor Teleport component for A-Frame.\n */\nAFRAME.registerComponent('cursor-teleport', {\n  schema: {\n    cameraHead: { type: 'selector', default: '' },\n    cameraRig: { type: 'selector', default: '' },\n    collisionEntities: { type: 'string', default: '' },\n    defaultPlaneSize: { type: 'number', default: 100 },\n    ignoreEntities: { type: 'string', default: '' },\n    landingMaxAngle: { default: 45, min: 0, max: 360 },\n    landingNormal: { type: 'vec3', default: { x: 0, y: 1, z: 0 } },\n    transitionSpeed: { type: 'number', default: 0.0006 }\n  },\n\n  init() {\n    // platform detect\n    this.mobile =\n      AFRAME.utils.device.isMobile() ||\n      AFRAME.utils.device.isMobileDeviceRequestingDesktopSite();\n\n    // main app\n    const sceneEl = this.el.sceneEl;\n    this.canvas = sceneEl.renderer.domElement;\n\n    // camera\n    this.data.cameraHead.object3D.traverse((child) => {\n      if (child instanceof THREE.Camera) {\n        this.cam = child;\n      }\n    });\n    this.camForRotation = this.data.cameraHead.object3D; // This is the Group, parent of the PerspectiveCamera\n\n    this.camRig = this.data.cameraRig.object3D;\n\n    // collision\n    this.rayCaster = new THREE.Raycaster();\n    this.collisionObjectNormalMatrix = new THREE.Matrix3();\n    this.collisionWorldNormal = new THREE.Vector3();\n    this.referenceNormal = new THREE.Vector3();\n    this.rayCastObjects = [];\n\n    // Update collision normal\n    this.referenceNormal.copy(this.data.landingNormal);\n\n    // teleport indicator\n    const geo = new THREE.RingGeometry(0.25, 0.3, 32, 1);\n    geo.rotateX(-Math.PI / 2);\n    geo.translate(0, 0.02, 0);\n    const mat = new THREE.MeshBasicMaterial();\n    const indicatorRing = new THREE.Mesh(geo, mat);\n    this.teleportIndicator = indicatorRing;\n    this.teleportIndicator.visible = false;\n\n    sceneEl.object3D.add(this.teleportIndicator);\n\n    // transition\n    this.transitioning = false;\n    this.transitionProgress = 0;\n    this.transitionCamPosStart = new THREE.Vector3();\n    this.transitionCamPosEnd = new THREE.Vector3();\n    this.transitionCamQuaternionStart = new THREE.Quaternion();\n    this.transitionCamQuaternionEnd = new THREE.Quaternion();\n\n    // Bind functions\n    this.updateRaycastObjects = this.updateRaycastObjects.bind(this);\n    this.getMouseState = this.getMouseState.bind(this);\n    this.getTeleportPosition = this.getTeleportPosition.bind(this);\n    this.isValidNormalsAngle = this.isValidNormalsAngle.bind(this);\n    this.transition = this.transition.bind(this);\n    this.mouseMove = this.mouseMove.bind(this);\n    this.mouseDown = this.mouseDown.bind(this);\n    this.mouseUp = this.mouseUp.bind(this);\n    this.easeInOutQuad = this.easeInOutQuad.bind(this);\n    this.teleportTo = this.teleportTo.bind(this);\n    this.hideCursor = this.hideCursor.bind(this);\n\n    this.updateRaycastObjects();\n  },\n\n  remove() {\n    this.cam = null;\n    this.canvas = null;\n    this.rayCastObjects.length = 0;\n    this.el.sceneEl.object3D.remove(this.teleportIndicator);\n    this.teleportIndicator.material.dispose();\n    this.teleportIndicator.geometry.dispose();\n    this.teleportIndicator = null;\n    if (this.collisionMesh) {\n      this.collisionMesh.geometry.dispose();\n      this.collisionMesh.material.dispose();\n      this.collisionMesh = null;\n    }\n  },\n\n  play() {\n    const canvas = this.canvas;\n    canvas.addEventListener('mousedown', this.mouseDown, false);\n    canvas.addEventListener('mousemove', this.mouseMove, false);\n    canvas.addEventListener('mouseup', this.mouseUp, false);\n    canvas.addEventListener('touchstart', this.mouseDown, false);\n    canvas.addEventListener('touchmove', this.mouseMove, false);\n    canvas.addEventListener('touchend', this.mouseUp, false);\n    window.addEventListener('keydown', this.hideCursor, false);\n  },\n\n  pause() {\n    this.transitioning = false;\n    this.hideCursor();\n    const canvas = this.canvas;\n    canvas.removeEventListener('mousedown', this.mouseDown);\n    canvas.removeEventListener('mousemove', this.mouseMove);\n    canvas.removeEventListener('mouseup', this.mouseUp);\n    canvas.removeEventListener('touchstart', this.mouseDown);\n    canvas.removeEventListener('touchmove', this.mouseMove);\n    canvas.removeEventListener('touchend', this.mouseUp);\n    window.removeEventListener('keydown', this.hideCursor);\n  },\n\n  updateRaycastObjects() {\n    // updates the array of meshes we will need to raycast to\n    // clear the array of any existing meshes\n    this.rayCastObjects.length = 0;\n\n    if (this.data.collisionEntities !== '') {\n      // traverse collision entities and add their meshes to the rayCastEntities array.\n      const collisionEntities = this.el.sceneEl.querySelectorAll(\n        this.data.collisionEntities\n      );\n\n      collisionEntities.forEach((e) => {\n        e.object3D.traverse((child) => {\n          if (child.isMesh) {\n            // mark this mesh as a collision object\n            child.userData.collision = true;\n            this.rayCastObjects.push(child);\n          }\n        });\n      });\n    } else {\n      if (!this.collisionMesh) {\n        // if no collision entities are specified, create a default ground plane collision.\n        const geo = new THREE.PlaneGeometry(this.data.defaultPlaneSize, this.data.defaultPlaneSize, 1);\n        geo.rotateX(-Math.PI / 2);\n        const mat = new THREE.MeshNormalMaterial();\n        const collisionMesh = new THREE.Mesh(geo, mat);\n        // mark this mesh as a collision object\n        collisionMesh.userData.collision = true;\n        this.collisionMesh = collisionMesh;\n      }\n      this.rayCastObjects.push(this.collisionMesh);\n    }\n\n    // We may need some entities to be seen by the raycaster even though they are not teleportable.\n    // This prevents the user from unnesserily teleporting when clicking things like buttons or UI.\n    if (this.data.ignoreEntities !== '') {\n      const ignoreEntities = this.el.sceneEl.querySelectorAll(\n        this.data.ignoreEntities\n      );\n      ignoreEntities.forEach((e) => {\n        e.object3D.traverse((child) => {\n          if (child.isMesh) {\n            this.rayCastObjects.push(child);\n          }\n        });\n      });\n    }\n  },\n\n  getMouseState: (function () {\n    const coordinates = new THREE.Vector2();\n    return function (e) {\n      const rect = this.canvas.getBoundingClientRect();\n      if (e.clientX != null) {\n        coordinates.x = e.clientX - rect.left;\n        coordinates.y = e.clientY - rect.top;\n        return coordinates;\n      } else if (e.touches[0] != null) {\n        coordinates.x = e.touches[0].clientX - rect.left;\n        coordinates.y = e.touches[0].clientY - rect.top;\n        return coordinates;\n      }\n    };\n  })(),\n\n  getTeleportPosition: (function () {\n    const mouse = new THREE.Vector2();\n    return function (mouseX, mouseY) {\n      if (this.rayCastObjects.length !== 0) {\n        if (this.cam && this.canvas) {\n          const cam = this.cam;\n          const rect = this.canvas.getBoundingClientRect();\n\n          mouse.x = (mouseX / (rect.right - rect.left)) * 2 - 1;\n          mouse.y = -(mouseY / (rect.bottom - rect.top)) * 2 + 1;\n          this.rayCaster.setFromCamera(mouse, cam);\n          const intersects = this.rayCaster.intersectObjects(\n            this.rayCastObjects\n          );\n          if (\n            intersects.length !== 0 &&\n            this.isValidNormalsAngle(intersects[0].face.normal, intersects[0].object)\n          ) {\n            if (intersects[0].object.userData.collision === true) {\n              return intersects[0].point;\n            }\n            return false;\n          } else {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    };\n  })(),\n\n  isValidNormalsAngle(collisionNormal, collisionObject) {\n    this.collisionObjectNormalMatrix.getNormalMatrix(collisionObject.matrixWorld);\n    this.collisionWorldNormal.copy(collisionNormal).applyNormalMatrix(this.collisionObjectNormalMatrix);\n    const angleNormals = this.referenceNormal.angleTo(this.collisionWorldNormal);\n    return THREE.MathUtils.RAD2DEG * angleNormals <= this.data.landingMaxAngle;\n  },\n\n  transition(destPos, destQuaternion = undefined) {\n    this.transitionProgress = 0;\n    this.transitionCamPosEnd.copy(destPos);\n    this.transitionCamPosStart.copy(this.camRig.position);\n    if (destQuaternion) {\n      this.transitionCamQuaternionEnd.copy(destQuaternion);\n      this.transitionCamQuaternionStart.copy(this.camRig.quaternion);\n    } else {\n      this.transitionCamQuaternionEnd.copy(this.camRig.quaternion);\n      this.transitionCamQuaternionStart.copy(this.transitionCamQuaternionEnd);\n    }\n    this.transitioning = true;\n    this.el.emit('navigation-start');\n  },\n\n  hideCursor() {\n    this.teleportIndicator.visible = false;\n  },\n\n  mouseMove(e) {\n    const mouseState = this.getMouseState(e);\n    this.mouseX = mouseState.x;\n    this.mouseY = mouseState.y;\n  },\n\n  mouseDown(e) {\n    this.updateRaycastObjects();\n\n    const mouseState = this.getMouseState(e);\n    this.mouseX = mouseState.x;\n    this.mouseY = mouseState.y;\n\n    this.mouseXOrig = mouseState.x;\n    this.mouseYOrig = mouseState.y;\n  },\n\n  mouseUp(e) {\n    if (this.mouseX === this.mouseXOrig && this.mouseY === this.mouseYOrig) {\n      const pos = this.getTeleportPosition(this.mouseX, this.mouseY);\n      if (pos) {\n        this.teleportIndicator.visible = true;\n        this.teleportIndicator.position.copy(pos);\n        this.transition(pos);\n      }\n    }\n  },\n\n  teleportTo(pos, quaternion = undefined) {\n    this.teleportIndicator.position.copy(pos);\n    if (!quaternion) {\n      this.transition(pos);\n    } else {\n      const destQuaternion = new THREE.Quaternion();\n      destQuaternion.setFromEuler(new THREE.Euler(0, this.camForRotation.rotation.y, 0));\n      destQuaternion.invert();\n      destQuaternion.multiply(quaternion);\n      this.transition(pos, destQuaternion);\n    }\n    // don't show the indicator when using via api\n    this.hideCursor();\n  },\n\n  easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  },\n\n  tick(time, delta) {\n    if (!this.transitioning && !this.mobile) {\n      const pos = this.getTeleportPosition(this.mouseX, this.mouseY);\n      if (pos) {\n        this.teleportIndicator.position.copy(pos);\n      }\n    }\n    if (this.transitioning) {\n      this.transitionProgress += delta * this.data.transitionSpeed;\n      const easeInOutTransitionProgress = this.easeInOutQuad(\n        this.transitionProgress\n      );\n\n      // set camera position\n      const camPos = this.camRig.position;\n      camPos.lerpVectors(\n        this.transitionCamPosStart,\n        this.transitionCamPosEnd,\n        easeInOutTransitionProgress\n      );\n\n      this.camRig.quaternion.slerpQuaternions(\n        this.transitionCamQuaternionStart,\n        this.transitionCamQuaternionEnd,\n        easeInOutTransitionProgress\n      );\n\n      if (this.transitionProgress >= 1) {\n        this.transitioning = false;\n        camPos.copy(this.transitionCamPosEnd);\n        this.camRig.quaternion.copy(this.transitionCamQuaternionEnd);\n        this.el.emit('navigation-end');\n      }\n    }\n  }\n});\n"],"names":[],"sourceRoot":""}