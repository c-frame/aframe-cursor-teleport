{"version":3,"file":"aframe-cursor-teleport-component.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;ACVA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C,kBAAkB,+BAA+B;AACjD,iBAAiB,+BAA+B;AAChD,yBAAyB,6BAA6B;AACtD,mBAAmB,mCAAmC;AACtD,kBAAkB,kEAAkE;AACpF,wBAAwB,8BAA8B;AACtD,sBAAsB,6BAA6B;AACnD,uBAAuB,+BAA+B;AACtD,qBAAqB,yBAAyB,oBAAoB;AAClE,uBAAuB;AACvB,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,KAAK;AACL,yDAAyD;;AAEzD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,8BAA8B;AAC5E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC","sources":["webpack://aframe-cursor-teleport-component/webpack/universalModuleDefinition","webpack://aframe-cursor-teleport-component/./index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","/* global AFRAME, THREE */\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n\n/**\n * Cursor Teleport component for A-Frame.\n */\nAFRAME.registerComponent('cursor-teleport', {\n  schema: {\n    enabled: { type: 'boolean', default: true },\n    cameraHead: { type: 'selector', default: '' },\n    cameraRig: { type: 'selector', default: '' },\n    collisionEntities: { type: 'string', default: '' },\n    cursorColor: { type: 'color', default: '#4d93fd' },\n    cursorType: { type: 'string', default: 'cylinder', oneOf: ['ring', 'cylinder'] },\n    defaultPlaneSize: { type: 'number', default: 100 },\n    ignoreEntities: { type: 'string', default: '' },\n    landingMaxAngle: { default: 45, min: 0, max: 360 },\n    landingNormal: { type: 'vec3', default: { x: 0, y: 1, z: 0 } },\n    transitionSpeed: { type: 'number', default: 0.0006 }\n  },\n\n  init() {\n    // platform detect\n    this.mobile = AFRAME.utils.device.isMobile() || AFRAME.utils.device.isMobileDeviceRequestingDesktopSite();\n\n    // main app\n    const sceneEl = this.el.sceneEl;\n    this.canvas = sceneEl.renderer.domElement;\n\n    // camera\n    this.data.cameraHead.object3D.traverse((child) => {\n      if (child instanceof THREE.Camera) {\n        this.cam = child; // This is the PerspectiveCamera\n      }\n    });\n    this.camForRotation = this.data.cameraHead.object3D; // This is the Group, parent of the PerspectiveCamera\n\n    this.camRig = this.data.cameraRig.object3D;\n\n    // collision\n    this.rayCaster = new THREE.Raycaster();\n    this.collisionObjectNormalMatrix = new THREE.Matrix3();\n    this.collisionWorldNormal = new THREE.Vector3();\n    this.referenceNormal = new THREE.Vector3();\n    this.rayCastObjects = [];\n\n    // Update collision normal\n    this.referenceNormal.copy(this.data.landingNormal);\n\n    // RING teleport indicator\n    const geo = new THREE.RingGeometry(0.25, 0.3, 32, 1);\n    geo.rotateX(-Math.PI / 2);\n    geo.translate(0, 0.02, 0);\n    const mat = new THREE.MeshBasicMaterial({ color: this.data.cursorColor });\n    const indicatorRing = new THREE.Mesh(geo, mat);\n    const group = new THREE.Group();\n    group.add(indicatorRing);\n    this.teleportIndicator = group;\n    this.teleportIndicator.visible = false;\n\n    if (this.data.cursorType === 'cylinder') {\n      // CYLINDER teleport indicator\n      const geoCyl = new THREE.CylinderGeometry(0.3, 0.3, 0.5, 32, 1, true);\n      geoCyl.translate(0, 0.25, 0);\n      // texture source MIT license https://github.com/fernandojsg/aframe-teleport-controls/blob/master/lib/cylinderTexture.js\n      const textureString =\n        'data:image/png;base64,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';\n      const textureCyl = new THREE.TextureLoader().load(textureString);\n      const matCyl = new THREE.MeshBasicMaterial({\n        color: this.data.cursorColor,\n        side: 'double',\n        map: textureCyl,\n        transparent: true,\n        depthTest: false\n      });\n      const indicatorCyl = new THREE.Mesh(geoCyl, matCyl);\n      group.add(indicatorCyl);\n    }\n\n    sceneEl.object3D.add(this.teleportIndicator);\n\n    // transition\n    this.transitioning = false;\n    this.transitionProgress = 0;\n    this.transitionCamPosStart = new THREE.Vector3();\n    this.transitionCamPosEnd = new THREE.Vector3();\n    this.transitionCamQuaternionStart = new THREE.Quaternion();\n    this.transitionCamQuaternionEnd = new THREE.Quaternion();\n\n    // Bind functions\n    this.updateRaycastObjects = this.updateRaycastObjects.bind(this);\n    this.getMouseState = this.getMouseState.bind(this);\n    this.getTeleportPosition = this.getTeleportPosition.bind(this);\n    this.isValidNormalsAngle = this.isValidNormalsAngle.bind(this);\n    this.transition = this.transition.bind(this);\n    this.mouseMove = this.mouseMove.bind(this);\n    this.mouseDown = this.mouseDown.bind(this);\n    this.mouseUp = this.mouseUp.bind(this);\n    this.easeInOutQuad = this.easeInOutQuad.bind(this);\n    this.teleportTo = this.teleportTo.bind(this);\n    this.hideCursor = this.hideCursor.bind(this);\n\n    this.updateRaycastObjects();\n  },\n\n  remove() {\n    this.cam = null;\n    this.canvas = null;\n    this.rayCastObjects.length = 0;\n    this.el.sceneEl.object3D.remove(this.teleportIndicator);\n    for (const child of this.teleportIndicator.children) {\n      child.material.dispose();\n      child.geometry.dispose();\n    }\n    this.teleportIndicator = null;\n    if (this.collisionMesh) {\n      this.collisionMesh.geometry.dispose();\n      this.collisionMesh.material.dispose();\n      this.collisionMesh = null;\n    }\n  },\n\n  update(oldData) {\n    if (typeof oldData.enabled === 'undefined') return;\n    if (!oldData.enabled && this.data.enabled) {\n      this.registerEventListeners();\n    }\n    if (oldData.enabled && !this.data.enabled) {\n      // Call unregisterEventListeners instead of pause that is a wrapped method unregistering tick method\n      // because we still want the tick method to use the component via the teleportTo api.\n      this.unregisterEventListeners();\n    }\n  },\n\n  registerEventListeners() {\n    const canvas = this.canvas;\n    canvas.addEventListener('mousedown', this.mouseDown, false);\n    canvas.addEventListener('mousemove', this.mouseMove, false);\n    canvas.addEventListener('mouseup', this.mouseUp, false);\n    canvas.addEventListener('touchstart', this.mouseDown, false);\n    canvas.addEventListener('touchmove', this.mouseMove, false);\n    canvas.addEventListener('touchend', this.mouseUp, false);\n    window.addEventListener('keydown', this.hideCursor, false);\n  },\n\n  unregisterEventListeners() {\n    this.transitioning = false;\n    this.hideCursor();\n    const canvas = this.canvas;\n    canvas.removeEventListener('mousedown', this.mouseDown);\n    canvas.removeEventListener('mousemove', this.mouseMove);\n    canvas.removeEventListener('mouseup', this.mouseUp);\n    canvas.removeEventListener('touchstart', this.mouseDown);\n    canvas.removeEventListener('touchmove', this.mouseMove);\n    canvas.removeEventListener('touchend', this.mouseUp);\n    window.removeEventListener('keydown', this.hideCursor);\n  },\n\n  play() {\n    if (!this.data.enabled) return;\n    this.registerEventListeners();\n  },\n\n  pause() {\n    this.unregisterEventListeners();\n  },\n\n  updateRaycastObjects() {\n    // updates the array of meshes we will need to raycast to\n    // clear the array of any existing meshes\n    this.rayCastObjects.length = 0;\n\n    if (this.data.collisionEntities !== '') {\n      // traverse collision entities and add their meshes to the rayCastEntities array.\n      const collisionEntities = this.el.sceneEl.querySelectorAll(this.data.collisionEntities);\n\n      collisionEntities.forEach((e) => {\n        e.object3D.traverse((child) => {\n          if (child.isMesh) {\n            // mark this mesh as a collision object\n            child.userData.collision = true;\n            this.rayCastObjects.push(child);\n          }\n        });\n      });\n    } else {\n      if (!this.collisionMesh) {\n        // if no collision entities are specified, create a default ground plane collision.\n        const geo = new THREE.PlaneGeometry(this.data.defaultPlaneSize, this.data.defaultPlaneSize, 1);\n        geo.rotateX(-Math.PI / 2);\n        const mat = new THREE.MeshNormalMaterial();\n        const collisionMesh = new THREE.Mesh(geo, mat);\n        // mark this mesh as a collision object\n        collisionMesh.userData.collision = true;\n        this.collisionMesh = collisionMesh;\n      }\n      this.rayCastObjects.push(this.collisionMesh);\n    }\n\n    // We may need some entities to be seen by the raycaster even though they are not teleportable.\n    // This prevents the user from unnesserily teleporting when clicking things like buttons or UI.\n    if (this.data.ignoreEntities !== '') {\n      const ignoreEntities = this.el.sceneEl.querySelectorAll(this.data.ignoreEntities);\n      ignoreEntities.forEach((e) => {\n        e.object3D.traverse((child) => {\n          if (child.isMesh) {\n            this.rayCastObjects.push(child);\n          }\n        });\n      });\n    }\n  },\n\n  getMouseState: (function () {\n    const coordinates = new THREE.Vector2();\n    return function (e) {\n      const rect = this.canvas.getBoundingClientRect();\n      if (e.clientX != null) {\n        coordinates.x = e.clientX - rect.left;\n        coordinates.y = e.clientY - rect.top;\n        return coordinates;\n      } else if (e.touches[0] != null) {\n        coordinates.x = e.touches[0].clientX - rect.left;\n        coordinates.y = e.touches[0].clientY - rect.top;\n        return coordinates;\n      }\n    };\n  })(),\n\n  getTeleportPosition: (function () {\n    const mouse = new THREE.Vector2();\n    return function (mouseX, mouseY) {\n      if (this.rayCastObjects.length !== 0) {\n        if (this.cam && this.canvas) {\n          const cam = this.cam;\n          const rect = this.canvas.getBoundingClientRect();\n\n          mouse.x = (mouseX / (rect.right - rect.left)) * 2 - 1;\n          mouse.y = -(mouseY / (rect.bottom - rect.top)) * 2 + 1;\n          this.rayCaster.setFromCamera(mouse, cam);\n          const intersects = this.rayCaster.intersectObjects(this.rayCastObjects);\n          if (intersects.length !== 0 && this.isValidNormalsAngle(intersects[0].face.normal, intersects[0].object)) {\n            if (intersects[0].object.userData.collision === true) {\n              return intersects[0].point;\n            }\n            return false;\n          } else {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    };\n  })(),\n\n  isValidNormalsAngle(collisionNormal, collisionObject) {\n    this.collisionObjectNormalMatrix.getNormalMatrix(collisionObject.matrixWorld);\n    this.collisionWorldNormal.copy(collisionNormal).applyNormalMatrix(this.collisionObjectNormalMatrix);\n    const angleNormals = this.referenceNormal.angleTo(this.collisionWorldNormal);\n    return THREE.MathUtils.RAD2DEG * angleNormals <= this.data.landingMaxAngle;\n  },\n\n  transition(destPos, destQuaternion = undefined) {\n    this.transitionProgress = 0;\n    this.transitionCamPosEnd.copy(destPos);\n    this.transitionCamPosStart.copy(this.camRig.position);\n    if (destQuaternion) {\n      this.transitionCamQuaternionEnd.copy(destQuaternion);\n      this.transitionCamQuaternionStart.copy(this.camRig.quaternion);\n    } else {\n      this.transitionCamQuaternionEnd.copy(this.camRig.quaternion);\n      this.transitionCamQuaternionStart.copy(this.transitionCamQuaternionEnd);\n    }\n    this.transitioning = true;\n    this.el.emit('navigation-start');\n  },\n\n  hideCursor() {\n    this.teleportIndicator.visible = false;\n  },\n\n  mouseMove(e) {\n    const mouseState = this.getMouseState(e);\n    this.mouseX = mouseState.x;\n    this.mouseY = mouseState.y;\n  },\n\n  mouseDown(e) {\n    this.updateRaycastObjects();\n\n    const mouseState = this.getMouseState(e);\n    this.mouseX = mouseState.x;\n    this.mouseY = mouseState.y;\n\n    this.mouseXOrig = mouseState.x;\n    this.mouseYOrig = mouseState.y;\n  },\n\n  mouseUp(e) {\n    if (this.mouseX === this.mouseXOrig && this.mouseY === this.mouseYOrig) {\n      const pos = this.getTeleportPosition(this.mouseX, this.mouseY);\n      if (pos) {\n        this.teleportIndicator.visible = true;\n        this.teleportIndicator.position.copy(pos);\n        this.transition(pos);\n      }\n    }\n  },\n\n  teleportTo(pos, quaternion = undefined) {\n    this.teleportIndicator.position.copy(pos);\n    if (!quaternion) {\n      this.transition(pos);\n    } else {\n      const destQuaternion = new THREE.Quaternion();\n      destQuaternion.setFromEuler(new THREE.Euler(0, this.camForRotation.rotation.y, 0));\n      destQuaternion.invert();\n      destQuaternion.multiply(quaternion);\n      this.transition(pos, destQuaternion);\n    }\n    // don't show the indicator when using via api\n    this.hideCursor();\n  },\n\n  easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  },\n\n  tick(time, delta) {\n    if (!this.transitioning && !this.mobile) {\n      const pos = this.getTeleportPosition(this.mouseX, this.mouseY);\n      if (pos) {\n        this.teleportIndicator.position.copy(pos);\n      }\n    }\n    if (this.transitioning) {\n      this.transitionProgress += delta * this.data.transitionSpeed;\n      const easeInOutTransitionProgress = this.easeInOutQuad(this.transitionProgress);\n      const value =\n        easeInOutTransitionProgress < 0.5 ? easeInOutTransitionProgress : 0.5 - 1 * (easeInOutTransitionProgress - 0.5);\n      this.teleportIndicator.scale.set(0.5 + value, 1, 0.5 + value);\n\n      // set camera position\n      const camPos = this.camRig.position;\n      camPos.lerpVectors(this.transitionCamPosStart, this.transitionCamPosEnd, easeInOutTransitionProgress);\n\n      this.camRig.quaternion.slerpQuaternions(\n        this.transitionCamQuaternionStart,\n        this.transitionCamQuaternionEnd,\n        easeInOutTransitionProgress\n      );\n\n      if (this.transitionProgress >= 1) {\n        this.transitioning = false;\n        camPos.copy(this.transitionCamPosEnd);\n        this.camRig.quaternion.copy(this.transitionCamQuaternionEnd);\n        this.el.emit('navigation-end');\n      }\n    }\n  }\n});\n"],"names":[],"sourceRoot":""}